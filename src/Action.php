<?php

/** Action class */
namespace Battis\BatchAction;

use \PWGen;

/**
 * Helper actions that can be used to buld installation steps
 *
 * @author Seth Battis <seth@battis.net>
 */
class Action {

	/**
	 * Load XML as an associative array
	 *
	 * @param string $xmlStringOrFilePath
	 *        	XML or a path to an XML file
	 *        	
	 * @return array
	 */
	public static function loadXmlAsArray($xmlStringOrFilePath) {

		/* load XML into a string for processing */
		$xml = $xmlStringOrFilePath;
		if (realpath($xmlStringOrFilePath)) {
			$xml = file_get_contents($xmlStringOrFilePath);
		}
		
		/* parse XML and recursively cast to associative array */
		return json_decode(
			json_encode(
				simplexml_load_string(
					// SimpleXML is dumb about CDATA:
					// http://php.net/manual/en/function.simplexml-load-string.php#82686
					preg_replace_callback('/<!\[CDATA\[(.*)\]\]>/', 
						function ($matches) {
							return trim(htmlspecialchars($matches [1]));
						}, $xml))), true);
	}

	/**
	 * Use HTTP basic access authentication to protect a directory
	 *
	 * Of particular interest (perhaps) is the flexibility of the `$users`
	 * parameter, which can be either a string (`"user"`) or an array of users
	 * (`["user1", "user2"]`). In both cases, passwords will be randomly
	 * generated for the users. Additionally, `$users` can be an associative
	 * array of users and passwords (`["user1" => "foo", "user2" => "bar"]`)
	 * or a mixed array (`["user1" => "foo", "user2", "user3"]`), in which
	 * case all users for whom a password is not specified will have a
	 * password randomly generated.
	 *
	 * In all cases, an associative array of users and passwords is returned,
	 * including both passwords passed as parameters and those generated by
	 * this method.
	 *
	 * @param string $dirPath
	 *        	Path to the directory to be protected
	 * @param string|string[] $users
	 *        	(Optional) User name(s) of authorized users (may be
	 *        	associative array: `[user => password']`) Default user is
	 *        	`admin`
	 * @param string $htpasswdFilePath
	 *        	Path to the htpasswd file to be updated
	 *        	
	 * @return string[] Passwords (optionally generated) for users as an
	 *         associative array: `[user => password]`
	 *        
	 * @throws Exception INVALID_PATH if `$dirPath` cannot be found or the
	 *         .htpasswd or .htaccess files cannot be created/updated,
	 *         INVALID_PARAMETER if `$users` cannot be parsed
	 */
	public static function httpAuthDir($dirPath, $users = 'admin', $htpasswdFilePath = null) {

		if (realpath($dirPath)) {
			
			/* convert a single username into an array */
			if (is_string($users)) {
				$users = array(
					$users => null 
				);
			}
			
			/*
			 * convert an array with mixed numeric and string keys (usernames)
			 * to use string values as keys to replace numeric keys
			 */
			$new = array();
			foreach ($users as $key => $value) {
				if (is_string($key)) {
					$new [$key] = $value;
				} else {
					$new [$value] = null;
				}
			}
			$users = $new;
			
			/*
			 * generate passwords for all users with empty passwords in the
			 * array
			 */
			if (is_array($users)) {
				$pwgen = new PWGen(16, true, true, true, false, false, true);
				foreach ($users as $user => $password) {
					if (empty($password)) {
						$users [$user] = $pwgen->generate();
					}
				}
			} else {
				throw new Exception(__METHOD__ . ': `$users` could not be understood', Exception::INVALID_PARAMETER);
			}
			
			/*
			 * use $dirPath as (a fairly insecure) location for unspecified
			 * $htpasswdFilePath
			 */
			// FIXME Find a more secure default location for .htpasswd file
			if (empty($htpasswdFilePath)) {
				$htpasswdFilePath = $dirPath . '/.htpasswd';
			}
			$htpasswd = "";
			if (realpath($htpasswdFilePath)) {
				$htpasswd = file_get_contents($htpasswdFilePath);
			}
			
			/* update/create .htpasswd file */
			// TODO It would be nice to include an option to delete existing
			// .htpasswd files and re-create from scratch
			foreach ($users as $user => $password) {
				$entry = $user . ':{SHA}' . base64_encode(
					sha1($password, TRUE)) . "\n";
				$count = 0;
				$htpasswd = preg_replace("/^$user:.*$\n/m", $entry, $htpasswd, 
					1, $count);
				if ($count < 1) {
					$htpasswd .= $entry;
				}
			}
			file_put_contents($htpasswdFilePath, $htpasswd);
			
			/* update/create .htaccess file */
			if (realpath($htpasswdFilePath)) {
				$pre = '# ' . __METHOD__ . " BEGIN\n";
				$post = '# ' . __METHOD__ . " END\n";
				// TODO It would be classy to support custom AuthName
				// parameters (e.g. the app name)
				$htaccess = "$pre<FilesMatch \"^.ht*\">\nOrder allow,deny\nDeny from all\n</FilesMatch>\n\nAuthType Basic\nAuthName \"Protected\"\nAuthUserFile $htpasswdFilePath\nRequire valid-user\n$post";
				$htaccessFilePath = $dirPath . '/.htaccess';
				
				if (realpath($htaccessFilePath)) {
					file_put_contents($htaccessFilePath, 
						preg_replace("/$pre(.*)$post/", $htaccess, 
							file_get_contents($htaccessFilePath)));
				} else {
					file_put_contents($htaccessFilePath, $htaccess);
				}
				
				if (!realpath($htaccessFilePath)) {
					throw new Exception(__METHOD__ . ": .htaccess file not found at `$htaccessFilePath`", Exception::INVALID_PATH);
				}
			} else {
				throw new Exception(__METHOD__ . ": .htpasswd file not found at `$htpasswdFilePath`", Exception::INVALID_PATH);
			}
		} else {
			throw new Exception(__METHOD__ . ": Directory `$dirPath` does not exist", Exception::INVALID_PATH);
		}
		
		return $users;
	}

	/**
	 * Create (and optionally populate) database tables
	 *
	 * Run a file (or string) of pre-defined SQL queries against a `mysqli`
	 * instance. If a `$testQuery` is included and returns at least
	 * `$testRowCount` rows, the pre-defined queries will not be run.
	 *
	 * @param \mysqli $sql        	
	 * @param string $sqlStringOrFilePath
	 *        	Either a valid SQL query or the path to a file containing a
	 *        	valid SQL query
	 * @param string $testQueryStringOrFilePath
	 *        	(Optional) Either a valid SQL query or path to a file
	 *        	containing a valid SQL query that returns a specific number
	 *        	of rows iff the database tables already exist. Default:
	 *        	`NULL`
	 * @param int $testRowCount
	 *        	The minimum number of rows that `$testQueryStringOrFilePath`
	 *        	must return (if provided)
	 *        	
	 * @return boolean `TRUE` if the creation query is run successfully,
	 *         `FALSE` otherwise
	 */
	public static function createDatabaseTables(\mysqli $sql, $sqlStringOrFilePath, $testQueryStringOrFilePath = null, $testRowCount = 1) {

		/* load schema into a string for processing */
		$schema = $sqlStringOrFilePath;
		if (realpath($sqlStringOrFilePath)) {
			$schema = file_get_contents($sqlStringOrFilePath);
		}
		
		/* test if tables already exist (if a test query was given) */
		if (!empty($testQueryStringOrFilePath)) {
			$test = $testQueryStringOrFilePath;
			if (realpath($testQueryStringOrFilePath)) {
				$test = file_get_contents($testQueryStringOrFilePath);
			}
			if ($sql->query($test)->num_rows >= $testRowCount) {
				return false;
			}
		}
		
		/* run the SQL queries to create the database tables */
		if (!$created) {
			$queries = explode(';', $schema);
			foreach ($queries as $query) {
				if (!$sql->query($query)) {
					throw new Exception(__METHOD__ . ": " . $sql->error, Exception::MYSQL_ERROR);
				}
			}
		}
		return true;
	}
}

?>